#!/usr/bin/env python3
from __future__ import annotations

import argparse
from pathlib import Path
import re
import subprocess
import sys

ROOT = Path(__file__).resolve().parents[1]
OUT = ROOT / "docs" / "TEMPLATE-HEALTH.md"


def rg_files(glob: str) -> int:
    cmd = ["rg", "--files", "-uu", "-g", glob]
    try:
        proc = subprocess.run(cmd, cwd=ROOT, capture_output=True, text=True, check=False)
    except FileNotFoundError as exc:
        raise RuntimeError("'rg' (ripgrep) is not installed or not in PATH") from exc

    if proc.returncode not in (0, 1):
        raise RuntimeError(proc.stderr.strip() or "rg failed")
    lines = [l for l in proc.stdout.splitlines() if l.strip()]
    return len(lines)


def count_fill_markers() -> tuple[int, int]:
    try:
        base_args = ["rg", "-uu", "-g", "*.md", "-g", "!.git"]

        files_cmd = base_args + ["--files-with-matches", r"\[FILL:"]
        proc_files = subprocess.run(files_cmd, cwd=ROOT, capture_output=True, text=True, check=False)
        if proc_files.returncode not in (0, 1):
            raise RuntimeError(f"rg failed for file count: {proc_files.stderr.strip() or 'rg failed'}")

        markers_cmd = base_args + ["-o", r"\[FILL:"]
        proc_markers = subprocess.run(markers_cmd, cwd=ROOT, capture_output=True, text=True, check=False)
        if proc_markers.returncode not in (0, 1):
            raise RuntimeError(f"rg failed for marker count: {proc_markers.stderr.strip() or 'rg failed'}")

        file_count = len([l for l in proc_files.stdout.splitlines() if l.strip()])
        marker_count = len([l for l in proc_markers.stdout.splitlines() if l.strip()])
        return file_count, marker_count
    except FileNotFoundError as exc:
        raise RuntimeError("'rg' (ripgrep) is not installed or not in PATH") from exc


def render() -> str:
    fill_files, fill_markers = count_fill_markers()
    universal_skills = rg_files(".agents/skills/**/SKILL.md")
    claude_skills = rg_files(".claude/skills/**/SKILL.md")
    agent_skills = rg_files(".agent/skills/**/SKILL.md")
    gha_workflows = rg_files(".github/workflows/*.yml")
    agent_workflows = rg_files(".agent/workflows/*.md")

    return "\n".join(
        [
            "# Template Health Report",
            "",
            "## Snapshot",
            "",
            "| Metric | Value |",
            "| --- | --- |",
            f"| Markdown files containing placeholders | {fill_files} |",
            f"| Total placeholder markers | {fill_markers} |",
            f"| Universal skills (`.agents`) | {universal_skills} |",
            f"| Claude skills (`.claude`) | {claude_skills} |",
            f"| Agent skills (`.agent`) | {agent_skills} |",
            f"| GitHub Actions workflows | {gha_workflows} |",
            f"| Agent workflow playbooks | {agent_workflows} |",
            "",
            "## Notes",
            "",
            "- This report is generated by `scripts/template-health-report.py`.",
            "- Run `python3 scripts/template-health-report.py` to refresh this file.",
            "",
        ]
    )


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--check", action="store_true", help="Fail if report is outdated")
    args = parser.parse_args()

    try:
        content = render()
    except RuntimeError as exc:
        print(f"[health] ERROR: {exc}", file=sys.stderr)
        return 1
    except OSError as exc:
        print(f"[health] ERROR: filesystem failure: {exc}", file=sys.stderr)
        return 1

    if args.check:
        if not OUT.exists():
            print(f"[health] ERROR: {OUT.relative_to(ROOT)} is missing", file=sys.stderr)
            return 1
        current = OUT.read_text(encoding="utf-8")
        if current != content:
            print(f"[health] ERROR: {OUT.relative_to(ROOT)} is out of date", file=sys.stderr)
            return 1
        print("[health] OK: template health report is up to date")
        return 0

    OUT.write_text(content, encoding="utf-8")
    print(f"[health] Wrote {OUT.relative_to(ROOT)}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
